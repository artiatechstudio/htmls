<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Breakout</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #gameCanvas {
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 0 0 5px #fff;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 30px;
            text-shadow: 0 0 10px #f0f;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
    </div>
    
    <div id="message" onclick="resetGame()">Click to Start</div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageEl = document.getElementById('message');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');

        let animationId;
        let gameRunning = false;
        
        // Game State
        let score = 0;
        let lives = 3;

        // Paddle
        const paddle = {
            width: 100,
            height: 15,
            x: canvas.width / 2 - 50,
            y: canvas.height - 30,
            color: '#0ff',
            speed: 8,
            dx: 0
        };

        // Ball
        const ball = {
            x: canvas.width / 2,
            y: canvas.height - 50,
            radius: 8,
            speed: 5,
            dx: 3,
            dy: -3,
            color: '#fff'
        };

        // Bricks
        const brickRowCount = 5;
        const brickColumnCount = 9;
        const brickPadding = 10;
        const brickOffsetTop = 50;
        const brickOffsetLeft = 35;
        const brickWidth = 75;
        const brickHeight = 20;

        let bricks = [];

        function initBricks() {
            bricks = [];
            for(let c=0; c<brickColumnCount; c++) {
                bricks[c] = [];
                for(let r=0; r<brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1, color: `hsl(${r * 40}, 70%, 50%)` };
                }
            }
        }

        // Particles
        let particles = [];
        
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = Math.random() * 3;
                this.velocity = {
                    x: (Math.random() - 0.5) * 5,
                    y: (Math.random() - 0.5) * 5
                };
                this.alpha = 1;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= 0.02;
            }
        }

        // Input
        let rightPressed = false;
        let leftPressed = false;

        document.addEventListener('keydown', (e) => {
            if(e.key == 'Right' || e.key == 'ArrowRight') rightPressed = true;
            else if(e.key == 'Left' || e.key == 'ArrowLeft') leftPressed = true;
        });

        document.addEventListener('keyup', (e) => {
            if(e.key == 'Right' || e.key == 'ArrowRight') rightPressed = false;
            else if(e.key == 'Left' || e.key == 'ArrowLeft') leftPressed = false;
        });
        
        // Mouse movement
        document.addEventListener('mousemove', (e) => {
            const relativeX = e.clientX - canvas.offsetLeft;
            if(relativeX > 0 && relativeX < canvas.width) {
                paddle.x = relativeX - paddle.width / 2;
            }
        });


        function createExplosion(x, y, color) {
            for(let i=0; i<10; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
            ctx.fillStyle = ball.color;
            ctx.fill();
            ctx.closePath();
            
            // Glow
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#fff";
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.fillStyle = paddle.color;
            ctx.fill();
            ctx.closePath();
            
            ctx.shadowBlur = 15;
            ctx.shadowColor = paddle.color;
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawBricks() {
            for(let c=0; c<brickColumnCount; c++) {
                for(let r=0; r<brickRowCount; r++) {
                    if(bricks[c][r].status == 1) {
                        const brickX = (c*(brickWidth+brickPadding)) + brickOffsetLeft;
                        const brickY = (r*(brickHeight+brickPadding)) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = bricks[c][r].color;
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        function drawParticles() {
            particles.forEach((p, index) => {
                if(p.alpha <= 0) particles.splice(index, 1);
                else {
                    p.update();
                    p.draw();
                }
            });
        }

        function collisionDetection() {
            for(let c=0; c<brickColumnCount; c++) {
                for(let r=0; r<brickRowCount; r++) {
                    const b = bricks[c][r];
                    if(b.status == 1) {
                        if(ball.x > b.x && ball.x < b.x+brickWidth && ball.y > b.y && ball.y < b.y+brickHeight) {
                            ball.dy = -ball.dy;
                            b.status = 0;
                            score++;
                            scoreEl.innerText = score;
                            createExplosion(b.x + brickWidth/2, b.y + brickHeight/2, b.color);
                            
                            // Win condition
                            if(score === brickRowCount * brickColumnCount) {
                                alert("YOU WIN, CONGRATULATIONS!");
                                document.location.reload();
                            }
                        }
                    }
                }
            }
        }

        function draw() {
            // Trail effect (clear with opacity)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawBricks();
            drawBall();
            drawPaddle();
            drawParticles();
            collisionDetection();

            // Ball Movement
            if(ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
                ball.dx = -ball.dx;
            }
            if(ball.y + ball.dy < ball.radius) {
                ball.dy = -ball.dy;
            } else if(ball.y + ball.dy > canvas.height - ball.radius) {
                if(ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                    // Paddle bounce logic (angle based on hit position)
                    let hitPoint = ball.x - (paddle.x + paddle.width/2);
                    hitPoint = hitPoint / (paddle.width/2);
                    
                    ball.dx = hitPoint * 5; // Influence X speed
                    ball.dy = -ball.dy;
                    ball.speed += 0.2;
                } else {
                    lives--;
                    livesEl.innerText = lives;
                    if(!lives) {
                        messageEl.style.display = 'block';
                        messageEl.innerText = 'GAME OVER\nClick to Restart';
                        gameRunning = false;
                        return; // Stop loop
                    } else {
                        // Reset ball
                        ball.x = canvas.width/2;
                        ball.y = canvas.height-30;
                        ball.dx = 3;
                        ball.dy = -3;
                        paddle.x = (canvas.width-paddle.width)/2;
                    }
                }
            }

            ball.x += ball.dx;
            ball.y += ball.dy;
            
            // Paddle Movement (Keyboard)
            if(rightPressed && paddle.x < canvas.width-paddle.width) {
                paddle.x += 7;
            }
            else if(leftPressed && paddle.x > 0) {
                paddle.x -= 7;
            }

            if(gameRunning) animationId = requestAnimationFrame(draw);
        }

        function resetGame() {
            lives = 3;
            score = 0;
            scoreEl.innerText = score;
            livesEl.innerText = lives;
            gameRunning = true;
            messageEl.style.display = 'none';
            initBricks();
            ball.x = canvas.width/2;
            ball.y = canvas.height-30;
            ball.dx = 3;
            ball.dy = -3;
            draw();
        }

        // Star background static
        function drawStars() {
            // We're clearing canvas every frame so we can't draw static stars easily without redrawing them
            // For now, let's just keep the black background with the trail effect
        }

        messageEl.style.display = 'block';
    </script>
</body>
</html>
